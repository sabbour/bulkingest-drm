using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.WindowsAzure.MediaServices.Client;
using Microsoft.WindowsAzure.MediaServices.Client.ContentKeyAuthorization;

namespace bulkingestdrm.shared
{
    public static class DRMHelper
    {
        /// <summary>
        /// Compute HMAC hash using SHA256 function
        /// </summary>
        /// <param name=”symmetricKey”>Base64 string of byte[32], generated by RNGCryptoServiceProvider</param>
        /// <param name=”unsignedToken”>Clear-text string to be hashed</param>
        /// <returns></returns>
        public static string Hash(string symmetricKey, string unsignedToken)

        {
            string signature = string.Empty;

            byte[] symmetricKeyData = Convert.FromBase64String(symmetricKey);
            using (var signatureAlgorithm = new System.Security.Cryptography.HMACSHA256(symmetricKeyData))
            {
                signature = System.Net.WebUtility.UrlEncode(Convert.ToBase64String(signatureAlgorithm.ComputeHash(System.Text.Encoding.ASCII.GetBytes(unsignedToken))));
            }
            return signature;
        }

        public static byte[] GenerateCryptographicallyStrongRandomBytes(int length)
        {
            byte[] bytes = new byte[length];
            //This type implements the IDisposable interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its Dispose method in a try/catch block. To dispose of it indirectly, use a language construct such as using (in C#) 
            using (var rng = new System.Security.Cryptography.RNGCryptoServiceProvider())
            {
                rng.GetBytes(bytes);
            }
            return bytes;
        }

        public static string GenerateTokenRequirementsString(string primaryVerificationKey, string alternativeVerificationKey, string scope, string issuer, bool requireContentKeyIdentifier, params TokenClaim[] claims)
        {
            var tokenTemplate = GenerateTokenRequirements(primaryVerificationKey, alternativeVerificationKey, scope, issuer, requireContentKeyIdentifier, claims);
            return TokenRestrictionTemplateSerializer.Serialize(tokenTemplate);
        }

        public static TokenRestrictionTemplate GenerateTokenRequirements(string primaryVerificationKey, string alternativeVerificationKey, string scope, string issuer, bool requireContentKeyIdentifier, params TokenClaim[] claims)
        {
            TokenRestrictionTemplate template = new TokenRestrictionTemplate(TokenType.SWT);

            template.PrimaryVerificationKey = new SymmetricVerificationKey(Convert.FromBase64String(primaryVerificationKey));
            template.AlternateVerificationKeys.Add(new SymmetricVerificationKey(Convert.FromBase64String(alternativeVerificationKey)));
            template.Audience = scope;
            template.Issuer = issuer;

            // This claim requires that the value of the claim in the token must match the key identifier of the key being requested by the client.
            // Adding this claim means that the token issued to the client authorizes access to the content key identifier listed in the token.
            if (requireContentKeyIdentifier)
                template.RequiredClaims.Add(TokenClaim.ContentKeyIdentifierClaim);

            // Add any other claims
            foreach (var claim in claims)
            {
                template.RequiredClaims.Add(claim);
            }

            return template;
        }

        public static byte[] GetRandomBuffer(int length)
        {
            var returnValue = new byte[length];

            using (var rng =  new System.Security.Cryptography.RNGCryptoServiceProvider())
            {
                rng.GetBytes(returnValue);
            }

            return returnValue;
        }

        public static string Base64Encode(this string plainText)
        {
            var plainTextBytes = System.Text.Encoding.UTF8.GetBytes(plainText);
            return System.Convert.ToBase64String(plainTextBytes);
        }

        public static string Base64Decode(this string base64EncodedData)
        {
            var base64EncodedBytes = System.Convert.FromBase64String(base64EncodedData);
            return System.Text.Encoding.UTF8.GetString(base64EncodedBytes);
        }

    }
}
